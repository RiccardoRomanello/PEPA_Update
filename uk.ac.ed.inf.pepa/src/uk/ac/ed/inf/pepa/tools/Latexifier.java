/*******************************************************************************
 * Copyright (c) 2006, 2009 University of Edinburgh.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the BSD Licence, which
 * accompanies this feature and can be downloaded from
 * http://groups.inf.ed.ac.uk/pepa/update/licence.txt
 *******************************************************************************/
package uk.ac.ed.inf.pepa.tools;

import java.io.*;
import java.util.LinkedList;

import uk.ac.ed.inf.pepa.parsing.*;

/**
 * Creates a LaTeX snippet from a PEPA model
 * 
 * @author mtribast
 * 
 */
// TODO Underscores
// TODO page length
// TODO options for printing rates
// TODO options for describing action sets separately
// TODO options for verbosity (comments)
// TODO options for assigning names to processes
// TODO latex commands for writing the important use packages anyway
public class Latexifier {

	/**
	 * Data structured holding syncronisation sets which will be displayed at
	 * the end of the model
	 * 
	 */
	private class SyncSet {
		public String name;

		public String value;
	}

	private StringBuffer buf;

	private ModelNode node;

	/* Customisable feature */
	private boolean isSetsOnSeparateLines = false;

	private double spaceBetweenSections = 2;

	/**
	 * Name to give to synchronisation sets
	 */
	private String setName = "S";

	private int setCount = 1;

	private LinkedList<SyncSet> sets = new LinkedList<SyncSet>();

	// line separator short cut
	private final String sep = System.getProperty("line.separator");

	/**
	 * Converts the given node into a LaTex snippet.
	 * 
	 * @param node
	 *            the given node to convert to a LaTeX snippet
	 * @param setsOnSeparateLines
	 *            <code>true</code> if action sets have to be described on
	 *            separate lines at the end of model description
	 */
	public Latexifier(ModelNode node) {
		this.node = node;
	}

	/**
	 * Set the label for set definitions on different lines
	 * 
	 * @param s
	 *            the label
	 * @throws IllegalArgumentException
	 *             if <code>null</code> or empy
	 */
	public void setLabel(String s) {
		if (s == null || s.equals(""))
			throw new IllegalArgumentException();
		this.setName = s;
	}

	/**
	 * Get the label for set definitions
	 * 
	 * @return the label
	 */
	public String getLabel() {
		return this.setName;
	}
	
	/**
	 * Set extra space between model sections.
	 * <p>
	 * It uses the [..ex] LaTeX command for this
	 * @param value
	 */
	public void setExtraSpace(double value) {
		this.spaceBetweenSections = value;
	}
	
	/**
	 * Returns the amount of space between section
	 * @return
	 */
	public double getExtraSpace() {
		return this.spaceBetweenSections;
	}

	/**
	 * @return <code>true</code> if sets will be described on separate lines
	 */
	public boolean isSetsOnSeparateLines() {
		return this.isSetsOnSeparateLines;
	}
	
	/**
	 * Set if the converter will describe sets on separate lines
	 * @param value
	 */
	public void setSetsOnSeparateLines(boolean value) {
		this.isSetsOnSeparateLines = value;
	}

	/**
	 * This method will always return the same string .
	 * <p>
	 * This object is not reusable, therefore a new LaTeX snippet for another
	 * model is created by instantiating a new Latexifier.
	 * 
	 * @return the snippet for this model
	 */
	public String getLatexSource() {

		this.buf = new StringBuffer();
		String initMessage = "% Automatically generated by PEPA2Latex" + sep
				+ "% --begin" + sep;
		buf.append(initMessage);

		buf.append("\\begin{displaymath}" + sep + "\t" + "\\begin{array}{rcl}"
				+ sep);
		node.accept(new LatexVisitor());
		buf.append("% --end");

		return buf.toString();
	}

	private class LatexVisitor implements ASTVisitor {

		public void visitActivityNode(ActivityNode activity) {
			buf.append("(");
			activity.getAction().accept(this);
			buf.append(",");
			activity.getRate().accept(this);
			buf.append(")");
		}

		public void visitActionTypeNode(ActionTypeNode actionType) {
			mathIt(actionType.getType());
		}

		public void visitChoiceNode(ChoiceNode choice) {
			choice.getLeft().accept(this);
			buf.append("+");
			choice.getRight().accept(this);
		}

		public void visitConstantProcessNode(ConstantProcessNode constant) {
			mathIt(constant.getName());
		}

		public void visitCooperationNode(CooperationNode cooperation) {
			cooperation.getLeft().accept(this);
			if (cooperation.getActionSet().size() == 0)
				buf.append("\\parallel");
			else
				buf.append("\\sync{" + actionSet(cooperation.getActionSet())
						+ "}");
			cooperation.getRight().accept(this);
		}

		public void visitHidingNode(HidingNode hiding) {
			hiding.getProcess().accept(this);
			buf.append("/");
			buf.append("\\lbrace" + actionSet(hiding.getActionSet())
					+ "\\rbrace");
		}

		private String actionSet(Actions actionSet) {
			StringBuffer as = new StringBuffer();
			for (ActionTypeNode action : actionSet)
				as.append(action.getType() + ",");
			as.deleteCharAt(as.length() - 1);
			if (!isSetsOnSeparateLines)
				return as.toString();
			SyncSet newSet = new SyncSet();
			newSet.name = setName + "_{" + setCount++ + "}";
			newSet.value = as.toString();
			sets.add(newSet);
			return newSet.name;

		}

		public void visitModelNode(ModelNode model) {
			for (RateDefinitionNode rateDef : model.rateDefinitions()) {
				buf.append("\t\t");
				rateDef.accept(this);
			}
			buf.append("[" + spaceBetweenSections + "ex]");

			for (ProcessDefinitionNode procDef : model.processDefinitions()) {
				buf.append("\t\t");
				procDef.accept(this);
			}
			buf.append("[" + spaceBetweenSections + "ex]");

			buf.append("\t\t\\multicolumn{3}{l}{");
			model.getSystemEquation().accept(this);
			buf.append("}");
			buf.append("\\\\" + sep);

			buf.append("[" + spaceBetweenSections + "ex]");

			if (isSetsOnSeparateLines) {
				handleSets();
			}
			buf.append("\t\\end{array}" + sep + "\\end{displaymath}" + sep);

		}

		private void handleSets() {
			for (SyncSet set : sets)
				buf.append("\t\t" + set.name + " & = & \\lbrace " + set.value
						+ "\\rbrace\\\\" + sep);
		}

		public void visitPassiveRateNode(PassiveRateNode passive) {
			if (passive.getMultiplicity() != 1)
				buf.append(passive.getMultiplicity() + "\\cdot");
			buf.append("\\top");
		}

		public void visitPrefixNode(PrefixNode prefix) {
			prefix.getActivity().accept(this);
			buf.append(".");
			prefix.getTarget().accept(this);
		}

		public void visitProcessDefinitionNode(
				ProcessDefinitionNode processDefinition) {
			mathIt(processDefinition.getName().getName());
			and();
			processDefinition.getNode().accept(this);
			buf.append("\\\\" + sep);
		}

		public void visitRateDefinitionNode(RateDefinitionNode rateDefinition) {
			mathIt(rateDefinition.getName().getName());
			buf.append(" & = & ");
			rateDefinition.getRate().accept(this);
			buf.append("\\\\" + sep);
		}

		public void visitRateDoubleNode(RateDoubleNode doubleRate) {
			buf.append(doubleRate.getValue() + "");
		}

		public void visitVariableRateNode(VariableRateNode variableRate) {
			mathIt(variableRate.getName());
		}

		public void visitBinaryOperatorRateNode(BinaryOperatorRateNode rate) {
			rate.getLeft().accept(this);
			buf.append(rate.getOperator().toString());
			rate.getRight().accept(this);
		}
		
		/**
		 * Aggregation no longer supports action sets -mtribast
		 */
		public void visitAggregationNode(AggregationNode aggregation) {
			aggregation.getProcessNode().accept(this);
			buf.append("[");
			aggregation.getCopies().accept(this);
			buf.append("]");
		}

		private void mathIt(String string) {
			buf.append("\\mathit{" + string + "}");
		}

		private void and() {
			buf.append(" & \\rmdef & ");
		}

		public void visitUnknownActionTypeNode(UnknownActionTypeNode unknownActionTypeNode) {
			buf.append("\tau");
			
		}
		
		public void visitWildcardCooperationNode(WildcardCooperationNode cooperation) {
			cooperation.getLeft().accept(this);
			buf.append("\\sync{*}");
			cooperation.getRight().accept(this);			
		}

	}

	/**
	 * Arg0 the model Arg1 the output file
	 */
	public static void main(String[] args) throws IOException {
		ModelNode model = (ModelNode) PepaTools.parse(readText(args[0]));
		Latexifier pepa2latex = new Latexifier(model);
		System.err.println(pepa2latex.getLatexSource());
		PrintWriter pw = null;
		pw = new PrintWriter(args[1]);
		pw.print(pepa2latex.getLatexSource());
		pw.close();

	}

	private static String readText(String fileName) throws IOException {
		String result = null;

		if (fileName != null) {
			File file = new File(fileName);
			StringBuffer sb = new StringBuffer();
			BufferedReader br = null;
			try {
				br = new BufferedReader(new FileReader(file));
				String line = null;
				String lineSearator = System.getProperty("line.separator");
				while ((line = br.readLine()) != null) { // while not
					// at the
					// end of the file
					// stream do
					sb.append(line);
					sb.append(lineSearator);
				}// next line
				result = sb.toString();
			} finally {
				if (br != null) {
					try {
						br.close();
					} catch (IOException ioe) {
						ioe.printStackTrace(System.err);
					}
				}
			}
		}// else: input unavailable

		return result;
	}// readText()

}
