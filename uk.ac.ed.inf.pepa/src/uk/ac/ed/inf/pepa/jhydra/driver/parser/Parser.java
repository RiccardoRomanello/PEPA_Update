/* Generated By:JavaCC: Do not edit this line. Parser.java */

package uk.ac.ed.inf.pepa.jhydra.driver.parser;

import uk.ac.ed.inf.pepa.jhydra.petrinet.*;
import java.util.Vector;
import java.util.Hashtable;

public class Parser implements ParserConstants {

	private static PetriNet myPN;

	private static Hashtable<String,Double> constants;

	private static double tStart = 0.0;
	private static double tStop = 0.0;
	private static double tStep = 0.0;

	private static String sourceCondition;
	private static String targetCondition;
	
	
	public double getTStart() { return tStart; }
	public double getTStop() { return tStop; }
	public double getTStep() { return tStep; }

	public String getSourceCondition() { return sourceCondition; }
	public String getTargetCondition() { return targetCondition; }

	public Hashtable<String,Double> getConstants() { return constants;}
	
	public void parse() {

		try {
			System.out.println("\n\nParsing model file...");
			InputFile();
			System.out.println("\n\nModel file parsed successfully...");

			System.out.println("\nPetri net has:");
			System.out.println("  " + myPN.getNumberOfPlaces() + " places");
			System.out.println("  " + myPN.getNumberOfTimedTransitions() + " timed transitions");
			System.out.println("  " + myPN.getNumberOfImmTransitions() + " immediate transitions");

		} catch (ParseException e) {
			System.out.println("Encountered errors during parse:");
			System.out.println(e);
			System.exit(-1);
		}
	}

	/*****************************************
	 * THE DNAMACA LANGUAGE GRAMMAR STARTS HERE *
	 *****************************************/

	/*
	 * Program structuring syntax follows.
	 */
	static final public void InputFile() throws ParseException {
		ModelDescription();
		label_1:
			while (true) {
				switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				case T_SOLUTION_CONTROL:
					;
					break;
				default:
					jj_la1[0] = jj_gen;
				break label_1;
				}
				SolutionControl();
			}
		label_2:
			while (true) {
				switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				case T_PASSAGE:
					;
					break;
				default:
					jj_la1[1] = jj_gen;
				break label_2;
				}
				PassageTimeDeclaration();
			}
			jj_consume_token(0);
	}

	static final public void ModelDescription() throws ParseException {
		jj_consume_token(T_MODEL);
		jj_consume_token(LBRACE);
		label_3:
			while (true) {
				switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				case T_STATE_VECTOR:
				case T_TRANSITION:
				case T_INITIAL:
				case T_CONSTANT:
					;
					break;
				default:
					jj_la1[2] = jj_gen;
				break label_3;
				}
				switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				case T_STATE_VECTOR:
					StateVector();
					break;
				case T_INITIAL:
					InitialState();
					break;
				case T_TRANSITION:
					Transition();
					break;
				case T_CONSTANT:
					Constant();
					break;
				default:
					jj_la1[3] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
				}
			}
		jj_consume_token(RBRACE);
	}

	static final public void StateVector() throws ParseException {
		jj_consume_token(T_STATE_VECTOR);
		jj_consume_token(LBRACE);
		label_4:
			while (true) {
				switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				case T_TYPE:
					;
					break;
				default:
					jj_la1[4] = jj_gen;
				break label_4;
				}
				jj_consume_token(T_TYPE);
				jj_consume_token(LBRACE);
				PrimitiveType();
				jj_consume_token(RBRACE);
				jj_consume_token(LBRACE);
				Token t = jj_consume_token(IDENTIFIER);

				System.out.println("Found place " + t.toString() + "...");

				myPN.addPlace(t.toString());

				label_5:
					while (true) {
						switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
						case COMMA:
							;
							break;
						default:
							jj_la1[5] = jj_gen;
						break label_5;
						}
						jj_consume_token(COMMA);
						Token t2 = jj_consume_token(IDENTIFIER);

						System.out.println("Found place " + t2.toString() + "...");

						myPN.addPlace(t2.toString());
					}
				jj_consume_token(RBRACE);
			}
		jj_consume_token(RBRACE);
	}

	static final public void InitialState() throws ParseException {
		jj_consume_token(T_INITIAL);
		jj_consume_token(LBRACE);
		label_6:
			while (true) {
				switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				case IDENTIFIER:
					;
					break;
				default:
					jj_la1[6] = jj_gen;
				break label_6;
				}
				StateAssignment();
			}
		jj_consume_token(RBRACE);
	}

	static final public void StateAssignment() throws ParseException {
		Token placeName = jj_consume_token(IDENTIFIER);
		jj_consume_token(ASSIGN);
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case IDENTIFIER:
			Token constantName = jj_consume_token(IDENTIFIER);
			Double iC = constants.get(constantName.toString());
			if(iC!=null)
				myPN.setTokens(placeName.toString(),iC.intValue());
			else{
				System.exit(-1);
			}
			break;
		case INTEGER_LITERAL:
			Token tokens = jj_consume_token(INTEGER_LITERAL);
			myPN.setTokens(placeName.toString(),new Integer(tokens.toString()).intValue());
			break;
			/*
    case FLOATING_POINT_LITERAL:
      Token fTokens = jj_consume_token(FLOATING_POINT_LITERAL);
      break;
			 */
		default:
			jj_la1[7] = jj_gen;
		jj_consume_token(-1);
		throw new ParseException();
		}
		jj_consume_token(SEMICOLON);
	}

	static final public void Transition() throws ParseException {

		boolean isTimed;
		//double rate = -1;
		double priority = 1;

		Token t_name, t_rate;

		String condition = "";
		String rate = "";

		Vector<String> inputPlaceNames = new Vector<String>(0,1);
		Vector<String> outputPlaceNames = new Vector<String>(0,1);

		Vector<Integer> inputArcWeights = new Vector<Integer>(0,1);
		Vector<Integer> outputArcWeights = new Vector<Integer>(0,1);

		jj_consume_token(T_TRANSITION);
		jj_consume_token(LBRACE);
		t_name = jj_consume_token(IDENTIFIER);
		jj_consume_token(RBRACE);

		jj_consume_token(LBRACE);

//		TransitionEnablingCondition(inputPlaceNames, inputArcWeights);

		condition = TransitionEnablingCondition();

		System.out.println(condition);

		/*
	  jj_consume_token(T_CONDITION);
	  jj_consume_token(LBRACE);
	  ConditionalExpression();
	  jj_consume_token(RBRACE);
		 */

		jj_consume_token(T_ACTION);
		jj_consume_token(LBRACE);
		label_7:  
			while (true) {
				switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				case NEXT:
					;
					break;
				default:
					jj_la1[8] = jj_gen;
				break label_7;
				}
				/*
			  jj_consume_token(NEXT);
			  jj_consume_token(DEREF);
			  Assignment();
			  jj_consume_token(SEMICOLON);
				 */

				TransitionFiringAction(inputPlaceNames, inputArcWeights, outputPlaceNames, outputArcWeights);

			}
		jj_consume_token(RBRACE);
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case T_RATE:
			isTimed = true;
			jj_consume_token(T_RATE);
			jj_consume_token(LBRACE);
			
			rate = Expression();
			
			/*
//			Expression();
//			t_rate = jj_consume_token(FLOATING_POINT_LITERAL);
			switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			case FLOATING_POINT_LITERAL:
				t_rate = jj_consume_token(FLOATING_POINT_LITERAL);
				break;
			case IDENTIFIER:
				t_rate = jj_consume_token(IDENTIFIER);
				break;
			default:
				jj_la1[10] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
			}
			*/
			
			jj_consume_token(RBRACE);
			break;
		case T_WEIGHT:
			isTimed = false;
			jj_consume_token(T_WEIGHT);
			jj_consume_token(LBRACE);
//			Expression();
			t_rate = jj_consume_token(FLOATING_POINT_LITERAL);
			jj_consume_token(RBRACE);
			break;
		default:
			jj_la1[9] = jj_gen;
		jj_consume_token(-1);
		throw new ParseException();
		}
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case T_PRIORITY:
			jj_consume_token(T_PRIORITY);
			jj_consume_token(LBRACE);
			switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
			case INTEGER_LITERAL:
				jj_consume_token(INTEGER_LITERAL);
				break;
			case FLOATING_POINT_LITERAL:
				jj_consume_token(FLOATING_POINT_LITERAL);
				break;
			default:
				jj_la1[10] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
			}
			jj_consume_token(RBRACE);
			break;
		default:
			jj_la1[11] = jj_gen;
		;
		}
		jj_consume_token(RBRACE);

		if(isTimed){
			if(inputPlaceNames.size()!=inputArcWeights.size()){
				System.out.println("INTERNAL ERROR: Differing number of input places and arcs for transition " + t_name.toString() +"...");
				System.exit(-1);
			}

			if(outputPlaceNames.size()!=outputArcWeights.size()){
				System.out.println("INTERNAL ERROR: Differing number of output places and arcs for transition " + t_name.toString() +"...");
				System.exit(-1);
			}

//			TimedTransition tT = myPN.addTimedTransition(t_name.toString(), new Double(t_rate.toString()).doubleValue(), condition);
//			TimedTransition tT = myPN.addTimedTransition(t_name.toString(), " " + t_rate.toString() + " ", condition);
			TimedTransition tT = myPN.addTimedTransition(t_name.toString(), rate, condition);
			Place inputPlace, outputPlace;

			for(int i=0;i<inputPlaceNames.size();i++){
				inputPlace = myPN.getPlace(inputPlaceNames.get(i));
				myPN.addArc(inputPlace, tT, inputArcWeights.get(i));
			}

			for(int i=0;i<outputPlaceNames.size();i++){
				outputPlace = myPN.getPlace(outputPlaceNames.get(i));
				myPN.addArc(tT, outputPlace, outputArcWeights.get(i));
			}


		} else{
			System.out.println("ERROR: immediate transition detected (not currently supported by JHydra)...");
		}

	}

	static final public String TransitionEnablingCondition() throws ParseException {

		String tECondition;

		jj_consume_token(T_CONDITION);
		jj_consume_token(LBRACE);
		tECondition = Condition();
		jj_consume_token(RBRACE);

		return tECondition;

	}

	static final public String Expression() throws ParseException {

		Token t;
		
		String expression = new String("");

		label_8:
			while (true) {
				switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				case FLOATING_POINT_LITERAL:
				case INTEGER_LITERAL:
				case IDENTIFIER:
				case LPAREN:
				case RPAREN:
//				case GT:
//				case LT:
//				case BANG:
//				case EQ:
//				case LE:
//				case GE:
//				case NE:
//				case SC_OR:
//				case SC_AND:
				case PLUS:
				case MINUS:
				case STAR:
				case SLASH:
				case REM:
//				case HOOK:
//				case COLON:
					;
					break;
				default:
					jj_la1[12] = jj_gen;
				break label_8;
				}
				switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				case IDENTIFIER:
					t=jj_consume_token(IDENTIFIER);
					expression = expression + " " + t.toString();
					break;
				case INTEGER_LITERAL:
					t=jj_consume_token(INTEGER_LITERAL);
					expression = expression + " " + t.toString();
					break;
				case FLOATING_POINT_LITERAL:
					t=jj_consume_token(FLOATING_POINT_LITERAL);
					expression = expression + " " + t.toString();
					break;
				case LPAREN:
					t=jj_consume_token(LPAREN);
					expression = expression + " " + t.toString();
					break;
				case RPAREN:
					t=jj_consume_token(RPAREN);
					expression = expression + " " + t.toString();
					break;
				case STAR:
					t=jj_consume_token(STAR);
					expression = expression + " " + t.toString();
					break;
				case SLASH:
					t=jj_consume_token(SLASH);
					expression = expression + " " + t.toString();
					break;
				case REM:
					t=jj_consume_token(REM);
					expression = expression + " " + t.toString();
					break;
				case PLUS:
					t=jj_consume_token(PLUS);
					expression = expression + " " + t.toString();
					break;
				case MINUS:
					t=jj_consume_token(MINUS);
					expression = expression + " " + t.toString();
					break;
					/*
				case SC_AND:
					t=jj_consume_token(SC_AND);
					expression = expression + " " + t.toString();
					break;
				case SC_OR:
					t=jj_consume_token(SC_OR);
					expression = expression + " " + t.toString();
					break;
				case EQ:
					t=jj_consume_token(EQ);
					expression = expression + " " + t.toString();
					break;
				case NE:
					t=jj_consume_token(NE);
					expression = expression + " " + t.toString();
					break;
				case LE:
					t=jj_consume_token(LE);
					expression = expression + " " + t.toString();
					break;
				case GE:
					t=jj_consume_token(GE);
					expression = expression + " " + t.toString();
					break;
				case LT:
					t=jj_consume_token(LT);
					expression = expression + " " + t.toString();
					break;
				case GT:
					t=jj_consume_token(GT);
					expression = expression + " " + t.toString();
					break;
				case BANG:
					t=jj_consume_token(BANG);
					expression = expression + " " + t.toString();
					break;
					*/
					/*
				case HOOK:
					t=jj_consume_token(HOOK);
					expression = expression + " " + t.toString();
					break;
				case COLON:
					t=jj_consume_token(COLON);
					expression = expression + " " + t.toString();
					break;
					*/
				default:
					jj_la1[13] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
				}
			}
		
		expression = expression + " ";
		
		return expression;
	}

	
	
	static final public String Condition() throws ParseException {

		Token t;
		
		String condition = new String("");

		label_8:
			while (true) {
				switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				case INTEGER_LITERAL:
				case IDENTIFIER:
				case LPAREN:
				case RPAREN:
				case GT:
				case LT:
				case BANG:
				case EQ:
				case LE:
				case GE:
				case NE:
				case SC_OR:
				case SC_AND:
				case PLUS:
				case MINUS:
				case STAR:
				case SLASH:
				case REM:
					;
					break;
				default:
					jj_la1[12] = jj_gen;
				break label_8;
				}
				switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				case IDENTIFIER:
					t=jj_consume_token(IDENTIFIER);
					condition = condition + " " + t.toString();
					break;
				case INTEGER_LITERAL:
					t=jj_consume_token(INTEGER_LITERAL);
					condition = condition + " " + t.toString();
					break;
				case LPAREN:
					t=jj_consume_token(LPAREN);
					condition = condition + " " + t.toString();
					break;
				case RPAREN:
					t=jj_consume_token(RPAREN);
					condition = condition + " " + t.toString();
					break;
				case STAR:
					t=jj_consume_token(STAR);
					condition = condition + " " + t.toString();
					break;
				case SLASH:
					t=jj_consume_token(SLASH);
					condition = condition + " " + t.toString();
					break;
				case REM:
					t=jj_consume_token(REM);
					condition = condition + " " + t.toString();
					break;
				case PLUS:
					t=jj_consume_token(PLUS);
					condition = condition + " " + t.toString();
					break;
				case MINUS:
					t=jj_consume_token(MINUS);
					condition = condition + " " + t.toString();
					break;
				case SC_AND:
					t=jj_consume_token(SC_AND);
					condition = condition + " " + t.toString();
					break;
				case SC_OR:
					t=jj_consume_token(SC_OR);
					condition = condition + " " + t.toString();
					break;
				case EQ:
					t=jj_consume_token(EQ);
					condition = condition + " " + t.toString();
					break;
				case NE:
					t=jj_consume_token(NE);
					condition = condition + " " + t.toString();
					break;
				case LE:
					t=jj_consume_token(LE);
					condition = condition + " " + t.toString();
					break;
				case GE:
					t=jj_consume_token(GE);
					condition = condition + " " + t.toString();
					break;
				case LT:
					t=jj_consume_token(LT);
					condition = condition + " " + t.toString();
					break;
				case GT:
					t=jj_consume_token(GT);
					condition = condition + " " + t.toString();
					break;
				case BANG:
					t=jj_consume_token(BANG);
					condition = condition + " " + t.toString();
					break;
				default:
					jj_la1[13] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
				}
			}
		
		condition = condition + " ";
		
		return condition;
	}

	static final public void TransitionFiringAction(Vector<String> inputPlaceNames, Vector<Integer> inputArcWeights, Vector<String> outputPlaceNames, Vector<Integer> outputArcWeights) throws ParseException {

		Token t_place1, t_place2, t_arcWeight;

		boolean outputAction;

		jj_consume_token(NEXT);
		jj_consume_token(DEREF);

		t_place1 = jj_consume_token(IDENTIFIER);

		jj_consume_token(ASSIGN);
		t_place2 = jj_consume_token(IDENTIFIER);

		if(!(t_place1.toString().equals(t_place2.toString()))){
			System.out.println("ERROR: Confused over place names in transition action specification " +
					"(names " + t_place1.toString() + " and " + t_place2.toString() + " don't match)...");
			System.exit(-1);
		}

		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case PLUS:
			jj_consume_token(PLUS);
			outputAction = true;
			break;
		case MINUS:
			jj_consume_token(MINUS);
			outputAction = false;
			break;
		default:
			jj_la1[16] = jj_gen;
		jj_consume_token(-1);
		throw new ParseException();
		}
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case INTEGER_LITERAL:
			t_arcWeight = jj_consume_token(INTEGER_LITERAL);
			break;
//			case FLOATING_POINT_LITERAL:
//			jj_consume_token(FLOATING_POINT_LITERAL);
//			break;
//			case IDENTIFIER:
//			jj_consume_token(IDENTIFIER);
//			break;
		default:
			jj_la1[17] = jj_gen;
		jj_consume_token(-1);
		throw new ParseException();
		}
		jj_consume_token(SEMICOLON);

		if(outputAction){
			outputPlaceNames.add(t_place1.toString());
			outputArcWeights.add(new Integer(t_arcWeight.toString()));
		}else{
			inputPlaceNames.add(t_place1.toString());
			inputArcWeights.add(new Integer(t_arcWeight.toString()));   	
		}
	}


	static final public void Constant() throws ParseException {
		jj_consume_token(T_CONSTANT);
		jj_consume_token(LBRACE);
		Token t_name = jj_consume_token(IDENTIFIER);
		jj_consume_token(RBRACE);
		jj_consume_token(LBRACE);

		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case INTEGER_LITERAL:
			Token t_int = jj_consume_token(INTEGER_LITERAL);
			constants.put(t_name.toString(), new Double(t_int.toString()).doubleValue());   
			break;
		case FLOATING_POINT_LITERAL:
			Token t_float = jj_consume_token(FLOATING_POINT_LITERAL);
			constants.put(t_name.toString(), new Double(t_float.toString()).doubleValue()); 
			break;
		default:
			jj_la1[11] = jj_gen;
		jj_consume_token(-1);
		throw new ParseException();
		}
		jj_consume_token(RBRACE);
	}

	static final public void SolutionControl() throws ParseException {
		jj_consume_token(T_SOLUTION_CONTROL);
		jj_consume_token(LBRACE);
		label_8:
			while (true) {
				switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				case T_METHOD:
				case T_ACCURACY:
				case T_MAX_ITERATIONS:
					;
					break;
				default:
					jj_la1[12] = jj_gen;
				break label_8;
				}
				switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				case T_METHOD:
					SolutionMethod();
					break;
				case T_ACCURACY:
					SolutionAccuracy();
					break;
				case T_MAX_ITERATIONS:
					MaxIterations();
					break;
				default:
					jj_la1[13] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
				}
			}
		jj_consume_token(RBRACE);
	}

	static final public void SolutionMethod() throws ParseException {
		jj_consume_token(T_METHOD);
		jj_consume_token(LBRACE);
		jj_consume_token(METHOD_LITERAL);
		jj_consume_token(RBRACE);
	}

	static final public void SolutionAccuracy() throws ParseException {
		jj_consume_token(T_ACCURACY);
		jj_consume_token(LBRACE);
		jj_consume_token(FLOATING_POINT_LITERAL);
		jj_consume_token(RBRACE);
	}

	static final public void MaxIterations() throws ParseException {
		jj_consume_token(T_MAX_ITERATIONS);
		jj_consume_token(LBRACE);
		jj_consume_token(INTEGER_LITERAL);
		jj_consume_token(RBRACE);
	}

	static final public void PassageTimeDeclaration() throws ParseException {

		Token t_tStart, t_tStop, t_tStep;

		jj_consume_token(T_PASSAGE);
		jj_consume_token(LBRACE);
		jj_consume_token(T_SOURCE_CONDITION);
		jj_consume_token(LBRACE);

		sourceCondition = Condition();

		System.out.println("Found passage time source state specification: " + sourceCondition);

		jj_consume_token(RBRACE);
		jj_consume_token(T_TARGET_CONDITION);
		jj_consume_token(LBRACE);

		targetCondition = Condition();

		System.out.println("Found passage time target state specification: " + targetCondition);

		jj_consume_token(RBRACE);


		jj_consume_token(T_START);
		jj_consume_token(LBRACE);

		t_tStart = jj_consume_token(FLOATING_POINT_LITERAL);
		tStart = (new Double(t_tStart.toString())).doubleValue();

		System.out.println("Found passage time start time = " + tStart);

		jj_consume_token(RBRACE);


		jj_consume_token(T_STOP);
		jj_consume_token(LBRACE);

		t_tStop = jj_consume_token(FLOATING_POINT_LITERAL);
		tStop = (new Double(t_tStop.toString())).doubleValue();

		System.out.println("Found passage time start time = " + tStop);

		jj_consume_token(RBRACE);


		jj_consume_token(T_STEP);
		jj_consume_token(LBRACE);

		t_tStep = jj_consume_token(FLOATING_POINT_LITERAL);
		tStep = (new Double(t_tStep.toString())).doubleValue();

		System.out.println("Found passage time step parameter = " + tStep);

		jj_consume_token(RBRACE);

		jj_consume_token(RBRACE);
	}
	
	 static final public void PrimitiveType() throws ParseException {
		 switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
//		 case BOOLEAN:
//			 jj_consume_token(BOOLEAN);
//			 break;
		 case CHAR:
			 jj_consume_token(CHAR);
			 break;
//		 case BYTE:
//			 jj_consume_token(BYTE);
//			 break;
		 case SHORT:
			 jj_consume_token(SHORT);
			 break;
		 case INT:
			 jj_consume_token(INT);
			 break;
		 case LONG:
			 jj_consume_token(LONG);
			 break;
//		 case FLOAT:
//			 jj_consume_token(FLOAT);
//			 break;
//		 case DOUBLE:
//			 jj_consume_token(DOUBLE);
//			 break;
		 default:
			 jj_la1[21] = jj_gen;
		 jj_consume_token(-1);
		 throw new ParseException();
		 }
	 }
	  /*
  static private IntegerConstant getIntegerConstant(String name){

//	  System.out.println("Looking for Constant " + name + " amongst " + intConstants.size() + "...");

	  IntegerConstant iC;

	  for (int count = 0; count < intConstants.size(); count++) {
		  iC = intConstants.get(count);
		  if (iC.getName().equals(name)) {
//			  System.out.println("Found it!");
			  return iC;
	      }
	  }

	  System.out.println("ERROR: Constant " + name + " not found...");
	  return null;
  }

  static private FloatingPointConstant getFloatingPointConstant(String name){

//	  System.out.println("Looking for Constant " + name + " amongst " + intConstants.size() + "...");

	  FloatingPointConstant fPC;

	  for (int count = 0; count < fpConstants.size(); count++) {
		  fPC = fpConstants.get(count);
		  if (fPC.getName().equals(name)) {
//			  System.out.println("Found it!");
			  return fPC;
	      }
	  }

	  System.out.println("ERROR: Constant " + name + " not found...");
	  return null;
  }
	   */

	  static private boolean jj_2_1(int xla) {
		  jj_la = xla; jj_lastpos = jj_scanpos = token;
		  try { return !jj_3_1(); }
		  catch(LookaheadSuccess ls) { return true; }
		  finally { jj_save(0, xla); }
	  }

	  static private boolean jj_2_2(int xla) {
		  jj_la = xla; jj_lastpos = jj_scanpos = token;
		  try { return !jj_3_2(); }
		  catch(LookaheadSuccess ls) { return true; }
		  finally { jj_save(1, xla); }
	  }

	  static private boolean jj_2_3(int xla) {
		  jj_la = xla; jj_lastpos = jj_scanpos = token;
		  try { return !jj_3_3(); }
		  catch(LookaheadSuccess ls) { return true; }
		  finally { jj_save(2, xla); }
	  }

	  static private boolean jj_2_4(int xla) {
		  jj_la = xla; jj_lastpos = jj_scanpos = token;
		  try { return !jj_3_4(); }
		  catch(LookaheadSuccess ls) { return true; }
		  finally { jj_save(3, xla); }
	  }

	  static private boolean jj_2_5(int xla) {
		  jj_la = xla; jj_lastpos = jj_scanpos = token;
		  try { return !jj_3_5(); }
		  catch(LookaheadSuccess ls) { return true; }
		  finally { jj_save(4, xla); }
	  }

	  static private boolean jj_2_6(int xla) {
		  jj_la = xla; jj_lastpos = jj_scanpos = token;
		  try { return !jj_3_6(); }
		  catch(LookaheadSuccess ls) { return true; }
		  finally { jj_save(5, xla); }
	  }

	  static private boolean jj_2_7(int xla) {
		  jj_la = xla; jj_lastpos = jj_scanpos = token;
		  try { return !jj_3_7(); }
		  catch(LookaheadSuccess ls) { return true; }
		  finally { jj_save(6, xla); }
	  }

	  static private boolean jj_2_8(int xla) {
		  jj_la = xla; jj_lastpos = jj_scanpos = token;
		  try { return !jj_3_8(); }
		  catch(LookaheadSuccess ls) { return true; }
		  finally { jj_save(7, xla); }
	  }

	  static private boolean jj_2_9(int xla) {
		  jj_la = xla; jj_lastpos = jj_scanpos = token;
		  try { return !jj_3_9(); }
		  catch(LookaheadSuccess ls) { return true; }
		  finally { jj_save(8, xla); }
	  }

	  static private boolean jj_3R_74() {
		  if (jj_3R_76()) return true;
		  Token xsp;
		  while (true) {
			  xsp = jj_scanpos;
			  if (jj_3R_81()) { jj_scanpos = xsp; break; }
		  }
		  return false;
	  }

	  static private boolean jj_3R_71() {
		  if (jj_scan_token(COMMA)) return true;
		  if (jj_3R_36()) return true;
		  return false;
	  }

	  static private boolean jj_3R_70() {
		  if (jj_scan_token(SC_OR)) return true;
		  if (jj_3R_63()) return true;
		  return false;
	  }

	  static private boolean jj_3R_72() {
		  if (jj_3R_74()) return true;
		  Token xsp;
		  while (true) {
			  xsp = jj_scanpos;
			  if (jj_3R_79()) { jj_scanpos = xsp; break; }
		  }
		  return false;
	  }

	  static private boolean jj_3R_67() {
		  if (jj_scan_token(HOOK)) return true;
		  if (jj_3R_36()) return true;
		  if (jj_scan_token(COLON)) return true;
		  if (jj_3R_53()) return true;
		  return false;
	  }

	  static private boolean jj_3R_69() {
		  if (jj_3R_72()) return true;
		  Token xsp;
		  while (true) {
			  xsp = jj_scanpos;
			  if (jj_3R_77()) { jj_scanpos = xsp; break; }
		  }
		  return false;
	  }

	  static private boolean jj_3R_65() {
		  if (jj_3R_68()) return true;
		  return false;
	  }

	  static private boolean jj_3R_68() {
		  if (jj_3R_36()) return true;
		  Token xsp;
		  while (true) {
			  xsp = jj_scanpos;
			  if (jj_3R_71()) { jj_scanpos = xsp; break; }
		  }
		  return false;
	  }

	  static private boolean jj_3R_66() {
		  if (jj_3R_69()) return true;
		  Token xsp;
		  while (true) {
			  xsp = jj_scanpos;
			  if (jj_3R_75()) { jj_scanpos = xsp; break; }
		  }
		  return false;
	  }

	  static private boolean jj_3R_62() {
		  if (jj_scan_token(LPAREN)) return true;
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_3R_65()) jj_scanpos = xsp;
		  if (jj_scan_token(RPAREN)) return true;
		  return false;
	  }

	  static private boolean jj_3R_63() {
		  if (jj_3R_66()) return true;
		  Token xsp;
		  while (true) {
			  xsp = jj_scanpos;
			  if (jj_3R_73()) { jj_scanpos = xsp; break; }
		  }
		  return false;
	  }

	  static private boolean jj_3R_60() {
		  if (jj_3R_63()) return true;
		  Token xsp;
		  while (true) {
			  xsp = jj_scanpos;
			  if (jj_3R_70()) { jj_scanpos = xsp; break; }
		  }
		  return false;
	  }

	  static private boolean jj_3_9() {
		  if (jj_3R_38()) return true;
		  if (jj_scan_token(IDENTIFIER)) return true;
		  return false;
	  }

	  static private boolean jj_3R_64() {
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_scan_token(115)) {
			  jj_scanpos = xsp;
			  if (jj_scan_token(100)) return true;
		  }
		  return false;
	  }

	  static private boolean jj_3R_53() {
		  if (jj_3R_60()) return true;
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_3R_67()) jj_scanpos = xsp;
		  return false;
	  }

	  static private boolean jj_3R_35() {
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_scan_token(139)) {
			  jj_scanpos = xsp;
			  if (jj_scan_token(167)) {
				  jj_scanpos = xsp;
				  if (jj_scan_token(168)) {
					  jj_scanpos = xsp;
					  if (jj_scan_token(172)) {
						  jj_scanpos = xsp;
						  if (jj_scan_token(165)) {
							  jj_scanpos = xsp;
							  if (jj_scan_token(166)) {
								  jj_scanpos = xsp;
								  if (jj_scan_token(173)) {
									  jj_scanpos = xsp;
									  if (jj_scan_token(174)) {
										  jj_scanpos = xsp;
										  if (jj_scan_token(175)) {
											  jj_scanpos = xsp;
											  if (jj_scan_token(169)) {
												  jj_scanpos = xsp;
												  if (jj_scan_token(171)) {
													  jj_scanpos = xsp;
													  if (jj_scan_token(170)) return true;
												  }
											  }
										  }
									  }
								  }
							  }
						  }
					  }
				  }
			  }
		  }
		  return false;
	  }

	  static private boolean jj_3R_61() {
		  if (jj_3R_64()) return true;
		  return false;
	  }

	  static private boolean jj_3_3() {
		  if (jj_3R_34()) return true;
		  if (jj_3R_35()) return true;
		  return false;
	  }

	  static private boolean jj_3R_52() {
		  if (jj_3R_34()) return true;
		  if (jj_3R_35()) return true;
		  if (jj_3R_36()) return true;
		  return false;
	  }

	  static private boolean jj_3R_56() {
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_scan_token(119)) {
			  jj_scanpos = xsp;
			  if (jj_scan_token(123)) {
				  jj_scanpos = xsp;
				  if (jj_scan_token(125)) {
					  jj_scanpos = xsp;
					  if (jj_scan_token(126)) {
						  jj_scanpos = xsp;
						  if (jj_3R_61()) {
							  jj_scanpos = xsp;
							  if (jj_scan_token(109)) return true;
						  }
					  }
				  }
			  }
		  }
		  return false;
	  }

	  static private boolean jj_3R_44() {
		  if (jj_3R_53()) return true;
		  return false;
	  }

	  static private boolean jj_3R_43() {
		  if (jj_3R_52()) return true;
		  return false;
	  }

	  static private boolean jj_3R_36() {
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_3R_43()) {
			  jj_scanpos = xsp;
			  if (jj_3R_44()) return true;
		  }
		  return false;
	  }

	  static private boolean jj_3R_59() {
		  if (jj_3R_62()) return true;
		  return false;
	  }

	  static private boolean jj_3R_58() {
		  if (jj_scan_token(DOT)) return true;
		  if (jj_scan_token(IDENTIFIER)) return true;
		  return false;
	  }

	  static private boolean jj_3R_57() {
		  if (jj_scan_token(LBRACKET)) return true;
		  if (jj_3R_36()) return true;
		  if (jj_scan_token(RBRACKET)) return true;
		  return false;
	  }

	  static private boolean jj_3R_51() {
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_3R_57()) {
			  jj_scanpos = xsp;
			  if (jj_3R_58()) {
				  jj_scanpos = xsp;
				  if (jj_3R_59()) return true;
			  }
		  }
		  return false;
	  }

	  static private boolean jj_3R_42() {
		  if (jj_3R_51()) return true;
		  return false;
	  }

	  static private boolean jj_3R_50() {
		  if (jj_scan_token(LPAREN)) return true;
		  if (jj_3R_36()) return true;
		  if (jj_scan_token(RPAREN)) return true;
		  return false;
	  }

	  static private boolean jj_3_2() {
		  if (jj_scan_token(DOT)) return true;
		  if (jj_scan_token(IDENTIFIER)) return true;
		  return false;
	  }

	  static private boolean jj_3R_49() {
		  if (jj_3R_55()) return true;
		  return false;
	  }

	  static private boolean jj_3R_48() {
		  if (jj_3R_56()) return true;
		  return false;
	  }

	  static private boolean jj_3R_41() {
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_3R_48()) {
			  jj_scanpos = xsp;
			  if (jj_3R_49()) {
				  jj_scanpos = xsp;
				  if (jj_3R_50()) return true;
			  }
		  }
		  return false;
	  }

	  static private boolean jj_3R_98() {
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_scan_token(152)) {
			  jj_scanpos = xsp;
			  if (jj_scan_token(153)) return true;
		  }
		  return false;
	  }

	  static private boolean jj_3R_55() {
		  if (jj_scan_token(IDENTIFIER)) return true;
		  Token xsp;
		  while (true) {
			  xsp = jj_scanpos;
			  if (jj_3_2()) { jj_scanpos = xsp; break; }
		  }
		  return false;
	  }

	  static private boolean jj_3R_34() {
		  if (jj_3R_41()) return true;
		  Token xsp;
		  while (true) {
			  xsp = jj_scanpos;
			  if (jj_3R_42()) { jj_scanpos = xsp; break; }
		  }
		  return false;
	  }

	  static private boolean jj_3_8() {
		  if (jj_3R_34()) return true;
		  if (jj_3R_35()) return true;
		  return false;
	  }

	  static private boolean jj_3R_47() {
		  if (jj_scan_token(LBRACKET)) return true;
		  if (jj_scan_token(RBRACKET)) return true;
		  return false;
	  }

	  static private boolean jj_3R_46() {
		  if (jj_3R_55()) return true;
		  return false;
	  }

	  static private boolean jj_3R_97() {
		  if (jj_3R_34()) return true;
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_3R_98()) jj_scanpos = xsp;
		  return false;
	  }

	  static private boolean jj_3R_54() {
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_scan_token(89)) {
			  jj_scanpos = xsp;
			  if (jj_scan_token(93)) {
				  jj_scanpos = xsp;
				  if (jj_scan_token(91)) {
					  jj_scanpos = xsp;
					  if (jj_scan_token(111)) {
						  jj_scanpos = xsp;
						  if (jj_scan_token(105)) {
							  jj_scanpos = xsp;
							  if (jj_scan_token(107)) {
								  jj_scanpos = xsp;
								  if (jj_scan_token(101)) {
									  jj_scanpos = xsp;
									  if (jj_scan_token(98)) return true;
								  }
							  }
						  }
					  }
				  }
			  }
		  }
		  return false;
	  }

	  static private boolean jj_3R_45() {
		  if (jj_3R_54()) return true;
		  return false;
	  }

	  static private boolean jj_3R_38() {
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_3R_45()) {
			  jj_scanpos = xsp;
			  if (jj_3R_46()) return true;
		  }
		  while (true) {
			  xsp = jj_scanpos;
			  if (jj_3R_47()) { jj_scanpos = xsp; break; }
		  }
		  return false;
	  }

	  static private boolean jj_3_7() {
		  if (jj_3R_38()) return true;
		  if (jj_scan_token(IDENTIFIER)) return true;
		  return false;
	  }

	  static private boolean jj_3R_96() {
		  if (jj_3R_97()) return true;
		  return false;
	  }

	  static private boolean jj_3R_95() {
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_scan_token(143)) {
			  jj_scanpos = xsp;
			  if (jj_scan_token(142)) return true;
		  }
		  if (jj_3R_84()) return true;
		  return false;
	  }

	  static private boolean jj_3R_93() {
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_3R_95()) {
			  jj_scanpos = xsp;
			  if (jj_3R_96()) return true;
		  }
		  return false;
	  }

	  static private boolean jj_3R_92() {
		  if (jj_scan_token(DECR)) return true;
		  if (jj_3R_34()) return true;
		  return false;
	  }

	  static private boolean jj_3R_90() {
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_scan_token(154)) {
			  jj_scanpos = xsp;
			  if (jj_scan_token(155)) return true;
		  }
		  if (jj_3R_82()) return true;
		  return false;
	  }

	  static private boolean jj_3R_94() {
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_scan_token(156)) {
			  jj_scanpos = xsp;
			  if (jj_scan_token(157)) {
				  jj_scanpos = xsp;
				  if (jj_scan_token(161)) return true;
			  }
		  }
		  if (jj_3R_84()) return true;
		  return false;
	  }

	  static private boolean jj_3R_37() {
		  if (jj_scan_token(IDENTIFIER)) return true;
		  if (jj_scan_token(COLON)) return true;
		  return false;
	  }

	  static private boolean jj_3R_91() {
		  if (jj_scan_token(INCR)) return true;
		  if (jj_3R_34()) return true;
		  return false;
	  }

	  static private boolean jj_3_5() {
		  if (jj_scan_token(LBRACKET)) return true;
		  if (jj_scan_token(RBRACKET)) return true;
		  return false;
	  }

	  static private boolean jj_3R_89() {
		  if (jj_3R_93()) return true;
		  return false;
	  }

	  static private boolean jj_3R_85() {
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_scan_token(162)) {
			  jj_scanpos = xsp;
			  if (jj_scan_token(163)) {
				  jj_scanpos = xsp;
				  if (jj_scan_token(164)) return true;
			  }
		  }
		  if (jj_3R_80()) return true;
		  return false;
	  }

	  static private boolean jj_3R_88() {
		  if (jj_3R_92()) return true;
		  return false;
	  }

	  static private boolean jj_3_1() {
		  if (jj_scan_token(COMMA)) return true;
		  if (jj_3R_33()) return true;
		  return false;
	  }

	  static private boolean jj_3R_87() {
		  if (jj_3R_91()) return true;
		  return false;
	  }

	  static private boolean jj_3R_84() {
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_3R_86()) {
			  jj_scanpos = xsp;
			  if (jj_3R_87()) {
				  jj_scanpos = xsp;
				  if (jj_3R_88()) {
					  jj_scanpos = xsp;
					  if (jj_3R_89()) return true;
				  }
			  }
		  }
		  return false;
	  }

	  static private boolean jj_3R_86() {
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_scan_token(154)) {
			  jj_scanpos = xsp;
			  if (jj_scan_token(155)) return true;
		  }
		  if (jj_3R_84()) return true;
		  return false;
	  }

	  static private boolean jj_3R_83() {
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_scan_token(141)) {
			  jj_scanpos = xsp;
			  if (jj_scan_token(140)) {
				  jj_scanpos = xsp;
				  if (jj_scan_token(147)) {
					  jj_scanpos = xsp;
					  if (jj_scan_token(148)) return true;
				  }
			  }
		  }
		  if (jj_3R_78()) return true;
		  return false;
	  }

	  static private boolean jj_3R_82() {
		  if (jj_3R_84()) return true;
		  Token xsp;
		  while (true) {
			  xsp = jj_scanpos;
			  if (jj_3R_94()) { jj_scanpos = xsp; break; }
		  }
		  return false;
	  }

	  static private boolean jj_3R_80() {
		  if (jj_3R_82()) return true;
		  Token xsp;
		  while (true) {
			  xsp = jj_scanpos;
			  if (jj_3R_90()) { jj_scanpos = xsp; break; }
		  }
		  return false;
	  }

	  static private boolean jj_3R_81() {
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_scan_token(146)) {
			  jj_scanpos = xsp;
			  if (jj_scan_token(149)) return true;
		  }
		  if (jj_3R_76()) return true;
		  return false;
	  }

	  static private boolean jj_3R_78() {
		  if (jj_3R_80()) return true;
		  Token xsp;
		  while (true) {
			  xsp = jj_scanpos;
			  if (jj_3R_85()) { jj_scanpos = xsp; break; }
		  }
		  return false;
	  }

	  static private boolean jj_3_6() {
		  if (jj_3R_37()) return true;
		  return false;
	  }

	  static private boolean jj_3R_79() {
		  if (jj_scan_token(BIT_AND)) return true;
		  if (jj_3R_74()) return true;
		  return false;
	  }

	  static private boolean jj_3R_76() {
		  if (jj_3R_78()) return true;
		  Token xsp;
		  while (true) {
			  xsp = jj_scanpos;
			  if (jj_3R_83()) { jj_scanpos = xsp; break; }
		  }
		  return false;
	  }

	  static private boolean jj_3R_40() {
		  if (jj_3R_36()) return true;
		  return false;
	  }

	  static private boolean jj_3R_33() {
		  Token xsp;
		  xsp = jj_scanpos;
		  if (jj_3R_39()) {
			  jj_scanpos = xsp;
			  if (jj_3R_40()) return true;
		  }
		  return false;
	  }

	  static private boolean jj_3R_39() {
		  if (jj_scan_token(LBRACE)) return true;
		  return false;
	  }

	  static private boolean jj_3_4() {
		  if (jj_scan_token(LBRACKET)) return true;
		  if (jj_3R_36()) return true;
		  return false;
	  }

	  static private boolean jj_3R_75() {
		  if (jj_scan_token(BIT_OR)) return true;
		  if (jj_3R_69()) return true;
		  return false;
	  }

	  static private boolean jj_3R_77() {
		  if (jj_scan_token(XOR)) return true;
		  if (jj_3R_72()) return true;
		  return false;
	  }

	  static private boolean jj_3R_73() {
		  if (jj_scan_token(SC_AND)) return true;
		  if (jj_3R_66()) return true;
		  return false;
	  }

	  static private boolean jj_initialized_once = false;
	  /** Generated Token Manager. */
	  static public ParserTokenManager token_source;
	  static JavaCharStream jj_input_stream;
	  /** Current token. */
	  static public Token token;
	  /** Next token. */
	  static public Token jj_nt;
	  static private int jj_ntk;
	  static private Token jj_scanpos, jj_lastpos;
	  static private int jj_la;
	  static private int jj_gen;
	  static final private int[] jj_la1 = new int[73];
	  static private int[] jj_la1_0;
	  static private int[] jj_la1_1;
	  static private int[] jj_la1_2;
	  static private int[] jj_la1_3;
	  static private int[] jj_la1_4;
	  static private int[] jj_la1_5;
	  static {
		  jj_la1_init_0();
		  jj_la1_init_1();
		  jj_la1_init_2();
		  jj_la1_init_3();
		  jj_la1_init_4();
		  jj_la1_init_5();
	  }
	  private static void jj_la1_init_0() {
		  jj_la1_0 = new int[] {0x80000000,0x0,0x4006100,0x4006100,0x200,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
	  }
	  private static void jj_la1_init_1() {
		  jj_la1_1 = new int[] {0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
	  }
	  private static void jj_la1_init_2() {
		  jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2a000000,0x0,0x2a000000,0x2a000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x84000000,0xae000000,0x84000000,0x0,0x0,0x0,0x10000000,0xae000000,0x10000000,0x0,0x2a000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
	  }
	  private static void jj_la1_init_3() {
		  jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x88800000,0x1000,0x8800000,0x0,0x8800000,0x0,0x0,0x0,0x0,0xe8882010,0x0,0xe8882010,0x80008a24,0x0,0x8a24,0x80208a24,0x0,0xe8882010,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe8882010,0x0,0xe8882010,0x0,0x0,0x0,0xe8882010,0x0,0x68882010,0x80010,0xe8882010,0x0,0xe8cc6152,0xe8cceb76,0xe8cc6152,0x0,0x0,0xe8882010,0x1,0xe8cceb76,0x1,0x8,0xe888aa34,0xe8882010,0xe8882010,0xe8882010,0x0,0x80000000,0x80000000,0xe8882010,};
	  }
	  private static void jj_la1_init_4() {
		  jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x40,0xf00c014,0x200,0xf00c014,0x0,0x40,0x0,0x0,0x200,0xf00c004,0x800,0x10000,0x400000,0x800000,0x80000000,0x0,0x40000000,0x240000,0x240000,0x183000,0x183000,0x0,0x0,0xc000000,0xc000000,0x30000000,0x30000000,0xc000000,0xf00c004,0xc000,0xc004,0x3000000,0x3000000,0x444,0x4,0x444,0x0,0x0,0xf00c004,0x200,0x3000114,0x3000114,0x3000114,0x200,0x3000000,0x4,0x0,0x3000114,0x0,0x0,0x3000004,0xf00c004,0x3000004,0x3000004,0x200,0x0,0x0,0xf00c004,};
	  }
	  private static void jj_la1_init_5() {
		  jj_la1_5 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffe0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x1c,0x1c,0x0,0x0,0x2,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
	  }
	  static final private JJCalls[] jj_2_rtns = new JJCalls[9];
	  static private boolean jj_rescan = false;
	  static private int jj_gc = 0;

	  /** Constructor with InputStream. */
	  public Parser(java.io.InputStream stream, PetriNet net, Hashtable<String,Double> cT) {
		  this(stream, null, net, cT);
	  }
	  /** Constructor with InputStream and supplied encoding */
	  public Parser(java.io.InputStream stream, String encoding, PetriNet net, Hashtable<String,Double> cT) {
		  if (jj_initialized_once) {
			  System.out.println("ERROR: Second call to constructor of static parser.  ");
			  System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
			  System.out.println("       during parser generation.");
			  throw new Error();
		  }
		  jj_initialized_once = true;
		  try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
		  token_source = new ParserTokenManager(jj_input_stream);
		  token = new Token();
		  myPN = net;
		  constants = cT;
		  jj_ntk = -1;
		  jj_gen = 0;
		  for (int i = 0; i < 73; i++) jj_la1[i] = -1;
		  for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
	  }

	  /** Reinitialise. */
	  static public void ReInit(java.io.InputStream stream) {
		  ReInit(stream, null);
	  }
	  /** Reinitialise. */
	  static public void ReInit(java.io.InputStream stream, String encoding) {
		  try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
		  ParserTokenManager.ReInit(jj_input_stream);
		  token = new Token();
		  jj_ntk = -1;
		  jj_gen = 0;
		  for (int i = 0; i < 73; i++) jj_la1[i] = -1;
		  for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
	  }

	  /** Constructor. */
	  public Parser(java.io.Reader stream) {
		  if (jj_initialized_once) {
			  System.out.println("ERROR: Second call to constructor of static parser. ");
			  System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
			  System.out.println("       during parser generation.");
			  throw new Error();
		  }
		  jj_initialized_once = true;
		  jj_input_stream = new JavaCharStream(stream, 1, 1);
		  token_source = new ParserTokenManager(jj_input_stream);
		  token = new Token();
		  jj_ntk = -1;
		  jj_gen = 0;
		  for (int i = 0; i < 73; i++) jj_la1[i] = -1;
		  for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
	  }

	  /** Reinitialise. */
	  static public void ReInit(java.io.Reader stream) {
		  jj_input_stream.ReInit(stream, 1, 1);
		  ParserTokenManager.ReInit(jj_input_stream);
		  token = new Token();
		  jj_ntk = -1;
		  jj_gen = 0;
		  for (int i = 0; i < 73; i++) jj_la1[i] = -1;
		  for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
	  }

	  /** Constructor with generated Token Manager. */
	  public Parser(ParserTokenManager tm) {
		  if (jj_initialized_once) {
			  System.out.println("ERROR: Second call to constructor of static parser. ");
			  System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
			  System.out.println("       during parser generation.");
			  throw new Error();
		  }
		  jj_initialized_once = true;
		  token_source = tm;
		  token = new Token();
		  jj_ntk = -1;
		  jj_gen = 0;
		  for (int i = 0; i < 73; i++) jj_la1[i] = -1;
		  for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
	  }

	  /** Reinitialise. */
	  public void ReInit(ParserTokenManager tm) {
		  token_source = tm;
		  token = new Token();
		  jj_ntk = -1;
		  jj_gen = 0;
		  for (int i = 0; i < 73; i++) jj_la1[i] = -1;
		  for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
	  }

	  static private Token jj_consume_token(int kind) throws ParseException {
		  Token oldToken;
		  if ((oldToken = token).next != null) token = token.next;
		  else token = token.next = ParserTokenManager.getNextToken();
		  jj_ntk = -1;
		  if (token.kind == kind) {
			  jj_gen++;
			  if (++jj_gc > 100) {
				  jj_gc = 0;
				  for (int i = 0; i < jj_2_rtns.length; i++) {
					  JJCalls c = jj_2_rtns[i];
					  while (c != null) {
						  if (c.gen < jj_gen) c.first = null;
						  c = c.next;
					  }
				  }
			  }
			  return token;
		  }
		  token = oldToken;
		  jj_kind = kind;
		  throw generateParseException();
	  }

	  static private final class LookaheadSuccess extends java.lang.Error { }
	  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
	  static private boolean jj_scan_token(int kind) {
		  if (jj_scanpos == jj_lastpos) {
			  jj_la--;
			  if (jj_scanpos.next == null) {
				  jj_lastpos = jj_scanpos = jj_scanpos.next = ParserTokenManager.getNextToken();
			  } else {
				  jj_lastpos = jj_scanpos = jj_scanpos.next;
			  }
		  } else {
			  jj_scanpos = jj_scanpos.next;
		  }
		  if (jj_rescan) {
			  int i = 0; Token tok = token;
			  while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
			  if (tok != null) jj_add_error_token(kind, i);
		  }
		  if (jj_scanpos.kind != kind) return true;
		  if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
		  return false;
	  }


	  /** Get the next Token. */
	  static final public Token getNextToken() {
		  if (token.next != null) token = token.next;
		  else token = token.next = ParserTokenManager.getNextToken();
		  jj_ntk = -1;
		  jj_gen++;
		  return token;
	  }

	  /** Get the specific Token. */
	  static final public Token getToken(int index) {
		  Token t = token;
		  for (int i = 0; i < index; i++) {
			  if (t.next != null) t = t.next;
			  else t = t.next = ParserTokenManager.getNextToken();
		  }
		  return t;
	  }

	  static private int jj_ntk() {
		  if ((jj_nt=token.next) == null)
			  return (jj_ntk = (token.next=ParserTokenManager.getNextToken()).kind);
		  else
			  return (jj_ntk = jj_nt.kind);
	  }

	  static private java.util.List<int[]> jj_expentries = 
		  									new java.util.ArrayList<int[]>();
	  static private int[] jj_expentry;
	  static private int jj_kind = -1;
	  static private int[] jj_lasttokens = new int[100];
	  static private int jj_endpos;

	  static private void jj_add_error_token(int kind, int pos) {
		  if (pos >= 100) return;
		  if (pos == jj_endpos + 1) {
			  jj_lasttokens[jj_endpos++] = kind;
		  } else if (jj_endpos != 0) {
			  jj_expentry = new int[jj_endpos];
			  for (int i = 0; i < jj_endpos; i++) {
				  jj_expentry[i] = jj_lasttokens[i];
			  }
			  jj_entries_loop: 
				  for (java.util.Iterator<int[]> it = jj_expentries.iterator(); it.hasNext();) {
				  int[] oldentry = (it.next());
				  if (oldentry.length == jj_expentry.length) {
					  for (int i = 0; i < jj_expentry.length; i++) {
						  if (oldentry[i] != jj_expentry[i]) {
							  continue jj_entries_loop;
						  }
					  }
					  jj_expentries.add(jj_expentry);
					  break jj_entries_loop;
				  }
			  }
			  if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
		  }
	  }

	  /** Generate ParseException. */
	  static public ParseException generateParseException() {
		  jj_expentries.clear();
		  boolean[] la1tokens = new boolean[177];
		  if (jj_kind >= 0) {
			  la1tokens[jj_kind] = true;
			  jj_kind = -1;
		  }
		  for (int i = 0; i < 73; i++) {
			  if (jj_la1[i] == jj_gen) {
				  for (int j = 0; j < 32; j++) {
					  if ((jj_la1_0[i] & (1<<j)) != 0) {
						  la1tokens[j] = true;
					  }
					  if ((jj_la1_1[i] & (1<<j)) != 0) {
						  la1tokens[32+j] = true;
					  }
					  if ((jj_la1_2[i] & (1<<j)) != 0) {
						  la1tokens[64+j] = true;
					  }
					  if ((jj_la1_3[i] & (1<<j)) != 0) {
						  la1tokens[96+j] = true;
					  }
					  if ((jj_la1_4[i] & (1<<j)) != 0) {
						  la1tokens[128+j] = true;
					  }
					  if ((jj_la1_5[i] & (1<<j)) != 0) {
						  la1tokens[160+j] = true;
					  }
				  }
			  }
		  }
		  for (int i = 0; i < 177; i++) {
			  if (la1tokens[i]) {
				  jj_expentry = new int[1];
				  jj_expentry[0] = i;
				  jj_expentries.add(jj_expentry);
			  }
		  }
		  jj_endpos = 0;
		  jj_rescan_token();
		  jj_add_error_token(0, 0);
		  int[][] exptokseq = new int[jj_expentries.size()][];
		  for (int i = 0; i < jj_expentries.size(); i++) {
			  exptokseq[i] = jj_expentries.get(i);
		  }
		  return new ParseException(token, exptokseq, tokenImage);
	  }

	  /** Enable tracing. */
	  static final public void enable_tracing() {
	  }

	  /** Disable tracing. */
	  static final public void disable_tracing() {
	  }

	  static private void jj_rescan_token() {
		  jj_rescan = true;
		  for (int i = 0; i < 9; i++) {
			  try {
				  JJCalls p = jj_2_rtns[i];
				  do {
					  if (p.gen > jj_gen) {
						  jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
						  switch (i) {
						  case 0: jj_3_1(); break;
						  case 1: jj_3_2(); break;
						  case 2: jj_3_3(); break;
						  case 3: jj_3_4(); break;
						  case 4: jj_3_5(); break;
						  case 5: jj_3_6(); break;
						  case 6: jj_3_7(); break;
						  case 7: jj_3_8(); break;
						  case 8: jj_3_9(); break;
						  }
					  }
					  p = p.next;
				  } while (p != null);
			  } catch(LookaheadSuccess ls) { }
		  }
		  jj_rescan = false;
	  }

	  static private void jj_save(int index, int xla) {
		  JJCalls p = jj_2_rtns[index];
		  while (p.gen > jj_gen) {
			  if (p.next == null) { p = p.next = new JJCalls(); break; }
			  p = p.next;
		  }
		  p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
	  }

	  static final class JJCalls {
		  int gen;
		  Token first;
		  int arg;
		  JJCalls next;
	  }

}
